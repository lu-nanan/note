# **Java GC**
---

- [**Java GC**](#java-gc)
    - [**JVM 内存区域的划分**](#jvm-内存区域的划分)
      - [**直接内存（Direct Memory）**](#直接内存direct-memory)
      - [**各区域的内存分配与回收**](#各区域的内存分配与回收)
      - [**常见问题与调优**](#常见问题与调优)
    - [**基础 GC 算法**](#基础-gc-算法)
      - [**标记-清除算法（Mark-Sweep）**](#标记-清除算法mark-sweep)
      - [**复制算法（Copying）**](#复制算法copying)
      - [**标记-整理算法（Mark-Compact）**](#标记-整理算法mark-compact)
      - [**分代收集算法（Generational Collection）**](#分代收集算法generational-collection)
    - [**现代 GC 算法**](#现代-gc-算法)
      - [**CMS（Concurrent Mark-Sweep）**](#cmsconcurrent-mark-sweep)
      - [**G1（Garbage-First）**](#g1garbage-first)
      - [**ZGC（Z Garbage Collector）**](#zgcz-garbage-collector)
      - [**Shenandoah**](#shenandoah)
    - [**GC 算法对比**](#gc-算法对比)
    - [**GC 调优参数示例**](#gc-调优参数示例)


### **JVM 内存区域的划分**

1. **堆（Heap）**  
   - **作用**：存放所有对象实例（`new` 创建的对象）和数组。  
   - **特点**：  
     - 线程共享，所有线程均可访问堆中的对象。  
     - 是垃圾回收（GC）的主要区域。  
   - **子区域**（分代设计，用于优化垃圾回收）：  
     - **新生代（Young Generation）**：  
       - **Eden 区**：对象初次分配的位置。  
       - **Survivor 区**（S0 和 S1）：存放从 Eden 区经过 Minor GC 存活的对象。  
     - **老年代（Old Generation）**：存放长期存活的对象（经过多次 Minor GC 仍存活的对象）。  
   - **配置参数**：  
     - `-Xms`：初始堆大小（如 `-Xms256m`）。  
     - `-Xmx`：最大堆大小（如 `-Xmx1024m`）。  
   - **异常**：`OutOfMemoryError`（当堆无法分配更多对象时抛出）。

2. **方法区（Method Area）**  
   - **作用**：存储类信息（如类名、方法代码、字段描述）、常量池、静态变量、JIT 编译后的代码等。  
   - **特点**：  
     - 线程共享。  
     - 在 JDK 8 之前称为“永久代（PermGen）”，使用 JVM 内存；JDK 8+ 改为“元空间（Metaspace）”，使用本地内存（Native Memory）。  
   - **配置参数**：  
     - JDK 8 之前：`-XX:PermSize`、`-XX:MaxPermSize`。  
     - JDK 8+：`-XX:MetaspaceSize`、`-XX:MaxMetaspaceSize`。  
   - **异常**：`OutOfMemoryError`（类元数据过多或元空间不足时抛出）。

3. **虚拟机栈（VM Stack）**  
   - **作用**：存储线程执行方法时的栈帧（Stack Frame），包括局部变量表、操作数栈、动态链接和方法出口。  
   - **特点**：  
     - 线程私有，生命周期与线程相同。  
     - 每个方法调用对应一个栈帧的入栈和出栈。  
   - **异常**：  
     - `StackOverflowError`（栈深度超过限制，如递归调用过深）。  
     - `OutOfMemoryError`（栈扩展失败，如线程过多）。  
   - **配置参数**：`-Xss`（设置栈大小，如 `-Xss1m`）。

4. **本地方法栈（Native Method Stack）**  
   - **作用**：为 JVM 调用本地（Native）方法（如 C/C++ 实现的方法）提供支持。  
   - **特点**：类似虚拟机栈，但服务于 Native 方法。  
   - **异常**：与虚拟机栈相同（`StackOverflowError` 和 `OutOfMemoryError`）。

5. **程序计数器（Program Counter Register）**  
   - **作用**：记录当前线程执行的字节码指令地址（或 Native 方法的 undefined 值）。  
   - **特点**：  
     - 线程私有，唯一无 `OutOfMemoryError` 的区域。  
     - 多线程切换时依赖程序计数器恢复执行位置。

#### **直接内存（Direct Memory）**
- **作用**：通过 `ByteBuffer.allocateDirect()` 分配的堆外内存，用于 NIO 操作（如文件读写、网络通信）。  
- **特点**：  
  - 不属于 JVM 内存规范，但受 JVM 管理（通过 `Unsafe` 类或 `Cleaner` 机制释放）。  
  - 避免了堆内存与 Native 内存的数据拷贝，提升性能。  
- **异常**：`OutOfMemoryError`（本地内存不足时抛出）。  
- **配置参数**：`-XX:MaxDirectMemorySize`（设置直接内存上限）。

#### **各区域的内存分配与回收**
1. **堆内存的分配与 GC**  
   - **对象分配流程**：  
     1. 对象优先在 Eden 区分配。  
     2. Eden 区满时触发 Minor GC，存活对象移动到 Survivor 区。  
     3. 多次 Survivor 区存活的对象晋升到老年代。  
     4. 老年代满时触发 Full GC（Major GC）。  
   - **GC 算法**：  
     - 新生代：复制算法（Copying）。  
     - 老年代：标记-清除（Mark-Sweep）或标记-整理（Mark-Compact）。

2. **方法区（元空间）的回收**  
   - 回收条件：类加载器被回收、类无实例、无引用等。  
   - 回收内容：无用的类元数据、常量池等。

3. **栈内存的自动释放**  
   - 栈帧随方法结束自动弹出，内存由 JVM 管理，无需垃圾回收。


#### **常见问题与调优**
1. **堆内存溢出（OOM）**  
   - **原因**：对象过多或内存泄漏（如未关闭的集合引用）。  
   - **解决**：增大堆大小（`-Xmx`）、优化代码或排查内存泄漏。

2. **元空间溢出**  
   - **原因**：动态生成大量类（如反射、动态代理）。  
   - **解决**：增大 `-XX:MaxMetaspaceSize` 或优化类加载逻辑。

3. **栈溢出**  
   - **原因**：递归调用过深或循环依赖。  
   - **解决**：增大 `-Xss` 或优化代码逻辑。

4. **直接内存溢出**  
   - **原因**：频繁分配大块堆外内存未释放。  
   - **解决**：显式调用 `System.gc()`（触发 `Cleaner`）或限制直接内存大小。

垃圾回收（Garbage Collection, GC）是 Java 内存管理的核心机制，其核心目标是自动回收不再使用的对象，释放内存资源。GC 算法决定了垃圾回收的效率、吞吐量和停顿时间（STW, Stop-The-World）。以下是主流 GC 算法的详细解析：

### **基础 GC 算法**
#### **标记-清除算法（Mark-Sweep）**
- **步骤**：
  1. **标记**：从 GC Roots（如栈中引用的对象、静态变量等）出发，遍历所有可达对象并标记为存活。
  2. **清除**：扫描堆内存，回收未被标记的对象（即垃圾）。
- **优点**：实现简单，无需移动对象。
- **缺点**：
  - **内存碎片**：回收后会产生不连续的内存空间，可能导致大对象无法分配。
  - **两次遍历**：标记和清除阶段均需遍历内存，效率较低。
- **应用场景**：老年代回收（如 CMS 的并发标记阶段）。

#### **复制算法（Copying）**
- **步骤**：
  1. **分区**：将内存分为大小相等的两块（From 和 To）。
  2. **复制存活对象**：将 From 区的存活对象复制到 To 区，并紧凑排列。
  3. **交换角色**：完成复制后，From 和 To 区交换角色。
- **优点**：
  - **无内存碎片**：对象在 To 区紧凑排列。
  - **高效**：仅遍历存活对象，适合存活率低的新生代。
- **缺点**：
  - **内存浪费**：需预留一半内存作为空闲区。
  - **对象存活率高时效率低**：复制大量存活对象成本高。
- **应用场景**：新生代回收（如 Serial、ParNew、Parallel Scavenge 收集器）。

#### **标记-整理算法（Mark-Compact）**
- **步骤**：
  1. **标记**：与标记-清除相同，标记所有存活对象。
  2. **整理**：将存活对象向内存一端移动，清理边界外的内存。
- **优点**：
  - **无内存碎片**：内存连续，适合大对象分配。
  - **内存利用率高**：无需预留额外空间。
- **缺点**：
  - **移动对象成本高**：需更新对象引用地址。
  - **两次遍历**：标记和整理均需遍历内存。
- **应用场景**：老年代回收（如 Serial Old、Parallel Old 收集器）。


#### **分代收集算法（Generational Collection）**
- **核心思想**：根据对象存活周期将堆内存划分为新生代（Young Generation）和老年代（Old Generation），不同代采用不同算法。
  - **新生代**：对象存活率低，使用**复制算法**（如 Eden → Survivor）。
  - **老年代**：对象存活率高，使用**标记-清除**或**标记-整理**。
- **跨代引用问题**：老年代对象可能引用新生代对象，需通过**记忆集（Remembered Set）**记录跨代引用，避免全堆扫描。

### **现代 GC 算法**
#### **CMS（Concurrent Mark-Sweep）**
- **目标**：减少老年代回收的停顿时间（低延迟）。
- **步骤**：
  1. **初始标记**（STW）：标记 GC Roots 直接可达的对象。
  2. **并发标记**：并发遍历对象图，标记存活对象。
  3. **重新标记**（STW）：修正并发标记期间变动的引用。
  4. **并发清除**：并发清理垃圾。
- **优点**：并发执行，停顿时间短。
- **缺点**：
  - **内存碎片**：需定期 Full GC 进行内存整理。
  - **CPU 敏感**：并发阶段占用 CPU 资源，可能影响吞吐量。
  - **浮动垃圾**：并发阶段新产生的垃圾需下次回收。
- **应用场景**：对延迟敏感的老年代回收（JDK 9 前常用，后被 G1 取代）。

#### **G1（Garbage-First）**
- **目标**：平衡吞吐量和延迟，支持大堆内存（如数十 GB）。
- **核心思想**：将堆划分为多个大小相等的 **Region**（默认 2048 个），每个 Region 可以是 Eden、Survivor 或 Old 区。
- **步骤**：
  1. **初始标记**（STW）：标记 GC Roots 直接可达的对象。
  2. **并发标记**：并发标记存活对象。
  3. **最终标记**（STW）：处理 SATB（Snapshot-At-The-Beginning）记录的引用变化。
  4. **筛选回收**（STW）：计算 Region 的回收价值（垃圾比例），优先回收高价值 Region（Garbage-First）。
- **优点**：
  - **可控停顿时间**：通过设定 `-XX:MaxGCPauseMillis` 控制最大停顿时间。
  - **局部整理**：回收时对 Region 内部进行复制整理，减少碎片。
- **缺点**：内存占用较高（需维护 Region 元数据）。
- **应用场景**：JDK 9+ 默认收集器，适用于大内存、低延迟场景。

| **特性**            | **CMS**                          | **G1**                              |
|---------------------|----------------------------------|-------------------------------------|
| **目标**            | 低延迟（老年代回收）             | 平衡吞吐与延迟，大堆内存优化        |
| **算法**            | 标记-清除（老年代）              | 分区域复制整理（局部标记-整理）     |
| **内存碎片**        | 严重，需 Full GC 整理            | 局部整理，碎片较少                  |
| **停顿时间**        | 初始标记和重新标记阶段短 STW     | 可预测的停顿时间（通过参数控制）    |
| **适用堆大小**      | 中小堆（4GB~8GB）                | 大堆（8GB+）                        |
| **JDK 版本支持**    | JDK 8 及之前主流，JDK 14 移除    | JDK 7+ 支持，JDK 9+ 默认            |
| **CPU 资源占用**    | 并发阶段占用较多 CPU              | 更高效的并发处理                    |


#### **ZGC（Z Garbage Collector）**
- **目标**：亚毫秒级停顿时间（<10ms），支持 TB 级堆内存。
- **核心技术**：
  - **染色指针（Colored Pointers）**：在指针中嵌入元数据（如标记、重映射信息），减少内存访问开销。
  - **读屏障（Load Barrier）**：在访问对象时处理指针状态，支持并发整理。
- **步骤**：
  1. **并发标记**：遍历对象图并标记存活对象。
  2. **并发预备重分配**：确定需回收的 Region。
  3. **并发重分配**：将存活对象复制到新 Region。
  4. **并发重映射**：更新对象引用地址。
- **优点**：
  - **极低停顿时间**：全程并发，仅初始标记阶段有极短 STW。
  - **无碎片**：通过复制整理保证内存连续。
- **缺点**：JDK 15+ 正式生产可用，对低版本兼容性有限。
- **应用场景**：超大规模内存、对延迟极度敏感的应用（如金融交易系统）。

#### **Shenandoah**
- **目标**：与 ZGC 类似，追求低停顿，但实现方式不同。
- **核心技术**：
  - **Brooks 指针**：每个对象额外存储一个转发指针，支持并发复制。
  - **并发整理**：通过读屏障和写屏障实现并发对象移动。
- **优点**：与 ZGC 竞争，在 JDK 12+ 中提供。
- **缺点**：社区支持度略低于 ZGC。

### **GC 算法对比**
| **算法**       | **吞吐量** | **停顿时间**   | **内存开销** | **碎片问题** | **适用场景**               |
|----------------|------------|----------------|--------------|--------------|---------------------------|
| **Serial**     | 中等       | 长（STW）      | 低           | 无（复制）   | 单核客户端应用             |
| **Parallel**   | 高         | 中等（STW）    | 低           | 无（复制）   | 多核、高吞吐量后端服务     |
| **CMS**        | 中等       | 短（部分并发） | 中等         | 有           | 老年代低延迟（JDK 8 前）   |
| **G1**         | 高         | 可控低延迟     | 高           | 局部整理      | 大堆、平衡吞吐与延迟       |
| **ZGC**        | 中等       | 极低（亚毫秒） | 高           | 无           | 超大堆、极致低延迟         |
| **Shenandoah** | 中等       | 极低           | 高           | 无           | 与 ZGC 类似，多版本兼容    |



### **GC 调优参数示例**
1. **选择 GC 算法**：
   - `-XX:+UseSerialGC`：启用 Serial + Serial Old。
   - `-XX:+UseParallelGC`：启用 Parallel Scavenge + Parallel Old。
   - `-XX:+UseG1GC`：启用 G1 收集器。
   - `-XX:+UseZGC`：启用 ZGC（JDK 15+）。

2. **控制停顿时间**：
   - `-XX:MaxGCPauseMillis=200`（G1 最大停顿时间目标）。

3. **堆内存分配**：
   - `-Xms4g -Xmx4g`：设置堆初始和最大大小为 4GB。



